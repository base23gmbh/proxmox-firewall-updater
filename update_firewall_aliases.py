#!/usr/bin/env python3
from __future__ import annotations

import configparser
from dataclasses import dataclass
from typing import List

SECTION_NAME = "alias to domain"
DEFAULT_COMMENT = "Generated by update_firewall_aliases.py"


@dataclass(frozen=True)
class DomainEntry:
    domain: str
    alias: str
    ip: str = ''


@dataclass(frozen=True)
class AliasEntry:
    name: str
    cidr: str
    comment: str


class Dependencies:
    """Interface for managing actions on pve firewall aliases and dns entries."""

    def domains_list(self) -> List[DomainEntry]: ...

    def alias_get(self, name: str) -> AliasEntry | None: ...

    def alias_create(self, alias: AliasEntry): ...

    def alias_set(self, alias: AliasEntry): ...

    def dns_resolve(self, domain: str) -> str: ...


def domain_to_alias_list(ini_content: str) -> List[DomainEntry]:
    config = configparser.ConfigParser()
    config.read_string(ini_content)
    if SECTION_NAME not in config:
        return []
    domain = []
    for key in config[SECTION_NAME]:
        domain.append(DomainEntry(domain=key, alias=config[SECTION_NAME][key]))
    return domain


def _update_domain_entry(domain_entry: DomainEntry, deps: Dependencies):
    ip = deps.dns_resolve(domain_entry.domain)
    if ip is None:
        return
    alias = deps.alias_get(domain_entry.alias)

    if alias is None:
        new_alias = AliasEntry(name=domain_entry.alias, cidr=ip, comment=DEFAULT_COMMENT)
        deps.alias_create(new_alias)
    else:
        if alias.cidr != ip:
            new_alias = AliasEntry(name=alias.name, cidr=ip, comment=alias.comment)
            deps.alias_set(new_alias)


def update_aliases(deps: Dependencies):
    for domain_entry in deps.domains_list():
        _update_domain_entry(domain_entry, deps)
